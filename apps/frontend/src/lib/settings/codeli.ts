//taken from https://rosettacode.org/wiki/LZW_compression
const keywords = [
    'function ',
    'for ',
    'while ',
    'do ',
    'if ',
    'then',
    'else',
    'repeat',
    'until',
    'return',
    'break',
    'continue',
    ' and ',
    ' or ',
    'not ',
    'in ',
    'true',
    'false',
    'nil',
    ' mod ',
    ' div ',
    ' .. ',
    ' <= ',
    ' >= ',
    ' != ',
    ' := ',
    'print(',
    'Array(',
    'len(',
    'push(',
    'pop(',
    'dequeue(',
    'floor(',
    'ceil(',
    'sqrt(',
    'pow(',
    'max(',
    'min(',
    'codepoint(',
    'char(',
]

/**
    Namespace for LZW compression and decompression.
    Methods:
        LZW.compress(uncompressed)
        LZW.decompress(compressed)
*/
export class Codeli 
{
    /**
        Perform the LZW compression
        uncompressed - String. The string on which to perform the compression.
    */
    static compress(uncompressed: string): [number[], number]
    {
        // Initialize dictionary
        let dictionary = new Map();
        let dictSize = 0;
        for (let i = 0; i < 256; i++)
        {
            dictionary.set(String.fromCodePoint(i), i);
            dictSize += 1;
        }

        for (const keyword of keywords) {
            const w = keyword 
            let p = w[0];
            for (let i = 1; i < w.length; i++) {
                p += w[i]
                if (!dictionary.has(p)) {
                    dictionary.set(p, dictSize)
                    dictSize += 1;
                }
            }
        }
        
        let word = '';
        let result = [];
        
        for (let i = 0, len = uncompressed.length; i < len; i++)
        {
            let curChar = uncompressed[i];
            let joinedWord = word + curChar;
            
            // Do not use dictionary[joinedWord] because javascript objects 
            // will return values for myObject['toString']
            if (dictionary.has(joinedWord)) 
            {
                word = joinedWord;
            }
            else
            {
                result.push(dictionary.get(word));
                // Add wc to the dictionary.
                dictionary.set(joinedWord, dictSize);
                dictSize += 1;
                word = curChar;
            }
        }
        
        if (word !== '')
        {
            result.push(dictionary.get(word));
        }

        return [result, dictSize];
    }
    
    /**
        Decompress LZW array generated by LZW.compress()
        compressed - Array. The array that holds LZW compressed data.
    */
    static decompress(compressed: number[]): string
    {
        // Initialize Dictionary (inverse of compress)
        let dictionary = new Map();
        let dictSize = 0;
        for (let i = 0; i < 256; i++)
        {
            dictionary.set(i, String.fromCodePoint(i));
            dictSize += 1;
        }

        let tmp = new Set()
        for (const keyword of keywords) {
            const w = keyword 
            let p = w[0]
            for (let i = 1; i < w.length; i++) {
                p = p.concat(w[i])
                if (!tmp.has(p)) {
                    tmp.add(p)
                    dictionary.set(dictSize, p);
                    dictSize += 1;
                }
            }
        }
        tmp = new Set()


        
        let word = dictionary.get(compressed[0]);
        let result = word;
        let entry = '';
        
        for (let i = 1, len = compressed.length; i < len; i++)
        {
            let curNumber = compressed[i];
            
            if (dictionary.has(curNumber))
            {
                entry = dictionary.get(curNumber);
            }
            else
            {
                if (curNumber === dictSize)
                {
                    entry = word + word[0];
                }
                else
                {
                    console.log(curNumber)
                    throw 'Error in processing';
                }
            }
            
            result += entry;
            
            // Add word + entry[0] to dictionary
            dictionary.set(dictSize, word + entry[0]);
            dictSize += 1;
            
            word = entry;
        }
        
        return result;
    }

    static urlsafe="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_!-*";

    static numsToStr(nums: number[], base: number) {
        let result = 0n
        for (const num of nums) {
            result *= BigInt(base)
            result += BigInt(num)
        }
        let encoded = ""
        while (result > 0n) {
            const pos = result % BigInt(Codeli.urlsafe.length)
            encoded += Codeli.urlsafe[Number(pos)];
            result /= BigInt(Codeli.urlsafe.length);
        }
        return encoded.split("").reverse().join("")
    }

    static strToNums(str: string, base: number) {
        let num = 0n
        for (const char of str) {
            num *= BigInt(Codeli.urlsafe.length)
            num += BigInt(Codeli.urlsafe.indexOf(char))
        }
        let result = []
        while (num > 0n) {
            const pos = num % BigInt(base)
            result.push(Number(pos))
            num /= BigInt(base)
        }
        return result.reverse()
    }

}
