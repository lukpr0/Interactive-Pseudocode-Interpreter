/**
    Namespace for LZW compression and decompression.
    Methods:
        LZW.compress(uncompressed)
        LZW.decompress(compressed)
*/
export class LZW 
{
    /**
        Perform the LZW compression
        uncompressed - String. The string on which to perform the compression.
    */
    static compress(uncompressed)
    {
        // Initialize dictionary
        let dictionary = {};
        for (let i = 0; i < 256; i++)
        {
            dictionary[String.fromCharCode(i)] = i;
        }
        
        let word = '';
        let result = [];
        let dictSize = 256;
        
        for (let i = 0, len = uncompressed.length; i < len; i++)
        {
            let curChar = uncompressed[i];
            let joinedWord = word + curChar;
            
            // Do not use dictionary[joinedWord] because javascript objects 
            // will return values for myObject['toString']
            if (dictionary.hasOwnProperty(joinedWord)) 
            {
                word = joinedWord;
            }
            else
            {
                result.push(dictionary[word]);
                // Add wc to the dictionary.
                dictionary[joinedWord] = dictSize++;
                word = curChar;
            }
        }
        
        if (word !== '')
        {
            result.push(dictionary[word]);
        }
        
        return [result, dictSize];
    }
    
    /**
        Decompress LZW array generated by LZW.compress()
        compressed - Array. The array that holds LZW compressed data.
    */
    static decompress(compressed)
    {
        // Initialize Dictionary (inverse of compress)
        let dictionary = {};
        for (let i = 0; i < 256; i++)
        {
            dictionary[i] = String.fromCharCode(i);
        }
        
        let word = String.fromCharCode(compressed[0]);
        let result = word;
        let entry = '';
        let dictSize = 256;
        
        for (let i = 1, len = compressed.length; i < len; i++)
        {
            let curNumber = compressed[i];
            
            if (dictionary[curNumber] !== undefined)
            {
                entry = dictionary[curNumber];
            }
            else
            {
                if (curNumber === dictSize)
                {
                    entry = word + word[0];
                }
                else
                {
                    throw 'Error in processing';
                    return null;
                }
            }
            
            result += entry;
            
            // Add word + entry[0] to dictionary
            dictionary[dictSize++] = word + entry[0];
            
            word = entry;
        }
        
        return result;
    }
}


function str2bin(str)
{
    const out = []
    for(let c of str)
    {
        var r=c.codePointAt(0);
        if(r<128)
        {
            out.push(r);
        } else if(r<128*128)
        {
            var h=(r>>7)|128;
            var l=(r&127);
            out.push(h);
            out.push(l);
        } else
        {
            var h=(r>>14)|128;
            var m=((r>>7)&127)|128;
            var l=(r&127);
            out.push(h);
            out.push(m);
            out.push(l);
        }
    }
    return out;
}
function bin2str(arr)
{
    var out="";
    for(var i=0;i<arr.length;i++)
    {
        var l=arr[i];
        if(l>=128)
        {
            if(l>128 && arr[i+1]<128)
            {
                l=((arr[i]&127)<<7)+arr[i+1];
                i++;
            } else
            {
                l=((arr[i]&127)<<14)+((arr[i+1]&127)<<7)+arr[i+2];
                i+=2;
            }
        }
        if(l)
        {
            out+=String.fromCodePoint(l);
        }
    }
    return out;
}


